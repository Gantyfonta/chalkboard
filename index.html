<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Realtime Chalkboard</title>
<style>
  html,body{height:100%;margin:0;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial;}
  .app{display:flex;height:100vh;}
  .left{flex:1;position:relative;display:flex;flex-direction:column;}
  canvas{flex:1;background:#111;touch-action:none;cursor:crosshair;}
  .toolbar{height:64px;display:flex;align-items:center;padding:8px;gap:8px;background:#0b0b0b;color:#eee;}
  .btn{padding:8px 12px;background:#222;border:1px solid #333;color:#eee;border-radius:6px;cursor:pointer;}
  .small{font-size:13px;padding:6px 8px}
  .right{width:260px;background:#0f0f10;color:#fff;padding:12px;box-shadow:-8px 0 24px rgba(0,0,0,0.6);display:flex;flex-direction:column;gap:10px;}
  .user{display:flex;gap:8px;align-items:center;padding:6px;border-radius:6px;}
  .dot{width:18px;height:18px;border-radius:50%;}
  .meta{font-size:13px;color:#cfcfcf}
  label{font-size:13px;color:#cfcfcf}
  input[type="range"]{width:120px}
</style>
</head>
<body>
<div class="app">
  <div class="left">
    <div class="toolbar">
      <button id="clearBtn" class="btn small">Clear board</button>
      <label class="meta">Brush: <span id="sizeLabel">4</span></label>
      <input id="size" type="range" min="1" max="40" value="4" />
      <label class="meta">Your color:</label>
      <div id="myColor" class="dot" title="your color" style="border:1px solid #333"></div>
      <div style="flex:1"></div>
      <div class="meta" id="status">Connecting...</div>
    </div>
    <canvas id="board"></canvas>
  </div>

  <div class="right">
    <div style="display:flex;justify-content:space-between;align-items:center;">
      <strong>Connected users</strong>
      <button id="download" class="btn small">Download PNG</button>
    </div>
    <div id="usersList" style="display:flex;flex-direction:column;gap:6px;overflow:auto"></div>

    <div style="margin-top:auto">
      <div class="meta">Instructions</div>
      <ul style="padding-left:18px;margin:6px 0 0 0;color:#cfcfcf;font-size:13px">
        <li>Draw with mouse / touch / stylus</li>
        <li>Brush size adjustable</li>
        <li>Strokes are saved only when you lift the pointer</li>
      </ul>
    </div>
  </div>
</div>

<script type="module">
/* --------- IMPORTANT: Paste YOUR Firebase config below --------- */
const firebaseConfig = {
  apiKey: "AIzaSyAeBlNLDMLmMvsfcTF5ZvEOnHdTdLeH9oQ",
  authDomain: "chalkboard-fd511.firebaseapp.com",
  databaseURL: "https://chalkboard-fd511-default-rtdb.firebaseio.com",
  projectId: "chalkboard-fd511",
  storageBucket: "chalkboard-fd511.appspot.com",
  messagingSenderId: "314025498738",
  appId: "1:314025498738:web:6c84fd27c512008a048aeb",
  measurementId: "G-9WJ3B7SFRV"
};

/* -------------------------------------------------------------- */

import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-app.js";
import { getDatabase, ref, push, onChildAdded, onChildRemoved, onValue, remove, set } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-database.js";
import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-auth.js";

const app = initializeApp(firebaseConfig);
const db = getDatabase(app);
const auth = getAuth(app);

const canvas = document.getElementById('board');
const ctx = canvas.getContext('2d', { alpha: false });
const sizeInput = document.getElementById('size');
const sizeLabel = document.getElementById('sizeLabel');
const myColorDot = document.getElementById('myColor');
const usersList = document.getElementById('usersList');
const clearBtn = document.getElementById('clearBtn');
const statusEl = document.getElementById('status');
const downloadBtn = document.getElementById('download');

let uid = null;
let myColor = '#ffffff';
let drawing = false;
let currentStroke = [];
let brushSize = parseInt(sizeInput.value, 10);
sizeLabel.textContent = brushSize;

// Palette (good high-contrast colors for chalkboard)
const PALETTE = [
  '#e6194b','#3cb44b','#ffe119','#4363d8','#f58231','#911eb4',
  '#46f0f0','#f032e6','#bcf60c','#fabebe','#008080','#e6beff',
  '#9A6324','#fffac8','#800000','#aaffc3'
];

// Helpers
function hashStringToIndex(s, n) {
  let h = 2166136261 >>> 0;
  for (let i=0;i<s.length;i++){
    h ^= s.charCodeAt(i);
    h = Math.imul(h, 16777619);
  }
  return Math.abs(h) % n;
}

function setCanvasSize() {
  const ratio = window.devicePixelRatio || 1;
  canvas.width = canvas.clientWidth * ratio;
  canvas.height = canvas.clientHeight * ratio;
  ctx.scale(ratio, ratio);
  // redraw all strokes when resizing - we maintain a local cache of strokes
  redrawAll();
}

// Local cache of strokes to redraw when needed
let strokeCache = {}; // strokeId -> strokeObject

function drawStrokeObj(stroke, opts = {}) {
  const points = stroke.points;
  if (!points || points.length === 0) return;
  ctx.lineJoin = 'round';
  ctx.lineCap = 'round';
  ctx.lineWidth = (opts.size || stroke.size || 4);
  ctx.strokeStyle = stroke.color || '#fff';
  ctx.beginPath();
  ctx.moveTo(points[0].x, points[0].y);
  for (let i = 1; i < points.length; i++) {
    ctx.lineTo(points[i].x, points[i].y);
  }
  ctx.stroke();
}

function redrawAll() {
  // fill background
  ctx.fillStyle = '#111';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  // draw cached strokes sorted by time
  const arr = Object.entries(strokeCache).map(([id, s])=>({id, ...s}));
  arr.sort((a,b)=> (a.ts||0)-(b.ts||0));
  for (const s of arr) drawStrokeObj(s);
}

// Pointer handling
canvas.addEventListener('pointerdown', (e)=>{
  canvas.setPointerCapture(e.pointerId);
  drawing = true;
  currentStroke = [];
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  currentStroke.push({x,y});
  // immediate local draw
  ctx.lineJoin = 'round';
  ctx.lineCap = 'round';
  ctx.lineWidth = brushSize;
  ctx.strokeStyle = myColor;
  ctx.beginPath();
  ctx.moveTo(x,y);
});

canvas.addEventListener('pointermove', (e)=>{
  if (!drawing) return;
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  currentStroke.push({x,y});
  ctx.lineTo(x,y);
  ctx.stroke();
});

function pushStrokeToDB(strokeObj) {
  // strokeObj: {uid, color, size, points, ts}
  const strokesRef = ref(db, 'strokes');
  push(strokesRef, strokeObj).catch(err=>console.error('push error',err));
}

canvas.addEventListener('pointerup', (e)=>{
  if (!drawing) return;
  drawing = false;
  canvas.releasePointerCapture(e.pointerId);
  if (currentStroke.length === 0) return;
  const strokeObj = {
    uid,
    color: myColor,
    size: brushSize,
    points: currentStroke,
    ts: Date.now()
  };
  // Save to local cache with a temporary random id for immediate redraw (will be replaced by DB id)
  // but we wait for DB child_added to populate proper id. For now just redraw is enough.
  pushStrokeToDB(strokeObj);
  currentStroke = [];
});

// brush size control
sizeInput.addEventListener('input', (e)=>{
  brushSize = parseInt(e.target.value,10);
  sizeLabel.textContent = brushSize;
});

// Download image
downloadBtn.addEventListener('click', ()=>{
  // create a PNG from canvas (scale for device pixel ratio)
  const link = document.createElement('a');
  link.download = 'chalkboard.png';
  // To get full resolution, create temporary canvas at devicePixelRatio times
  link.href = canvas.toDataURL('image/png');
  link.click();
});

// Clear
clearBtn.addEventListener('click', async ()=>{
  if (!confirm('Clear the board for everyone? This cannot be undone.')) return;
  try {
    await remove(ref(db, 'strokes'));
  } catch (err) {
    console.error(err);
    alert('Failed to clear board: ' + err.message);
  }
});

// Realtime DB listeners
function startRealtimeListeners() {
  const strokesRef = ref(db, 'strokes');
  onChildAdded(strokesRef, (snap)=>{
    const id = snap.key;
    const stroke = snap.val();
    // store locally and draw
    strokeCache[id] = stroke;
    drawStrokeObj(stroke);
  });
  onChildRemoved(strokesRef, (snap)=>{
    // When entire strokes node removed, Firebase triggers child_removed for each child; but if removed via remove(strokes),
    // we can detect empty and clear cache.
    // Simpler: when strokes node becomes null, onValue below handles clearing.
    delete strokeCache[snap.key];
    redrawAll();
  });
  // Also watch entire strokes node to detect full clear (null)
  onValue(strokesRef, (snap)=>{
    if (!snap.exists()) {
      strokeCache = {};
      redrawAll();
    }
  });
}

// Presence: write to /users/<uid> with color and timestamp, remove on disconnect
function setPresence() {
  const userRef = ref(db, `users/${uid}`);
  set(userRef, { color: myColor, ts: Date.now() }).catch(console.error);
  // simple onDisconnect cleanup
  const rt = db; // getDatabase already set; but onDisconnect requires ref from database API - using set + remove on window unload
  window.addEventListener('beforeunload', async ()=>{
    try { await remove(userRef); } catch(e){}
  });
  // Listen to users list
  const usersRef = ref(db, 'users');
  onValue(usersRef, (snap)=>{
    const users = snap.val() || {};
    usersList.innerHTML = '';
    for (const [k,u] of Object.entries(users)) {
      const div = document.createElement('div');
      div.className = 'user';
      div.innerHTML = `<div class="dot" style="background:${u.color};border:1px solid #222"></div>
                       <div style="flex:1"><div style="font-weight:600">${k===uid? 'You': 'User'}</div>
                       <div style="font-size:12px;color:#bfbfbf">${new Date(u.ts).toLocaleTimeString()}</div></div>`;
      usersList.appendChild(div);
    }
  });
}

// Authentication & init
statusEl.textContent = 'Signing in...';
signInAnonymously(auth).catch(err=>{
  statusEl.textContent = 'Auth error: ' + err.message;
  console.error(err);
});

onAuthStateChanged(auth, (user)=>{
  if (user) {
    uid = user.uid;
    // pick color deterministically
    myColor = PALETTE[hashStringToIndex(uid, PALETTE.length)];
    myColorDot.style.background = myColor;
    statusEl.textContent = 'Connected (uid: ' + uid.slice(0,6) + ')';
    // init
    setCanvasSize();
    startRealtimeListeners();
    setPresence();
    // draw existing snapshots once (onChildAdded will populate)
  } else {
    statusEl.textContent = 'Signed out';
  }
});

// handle resize
window.addEventListener('resize', () => {
  // wait briefly to avoid thrash
  clearTimeout(window._resizeTimeout);
  window._resizeTimeout = setTimeout(()=> {
    // Save current image? We rely on strokeCache to redraw.
    // Reset transform and redraw
    // Reset canvas scaling by reloading page scaling
    // Because ctx.scale is cumulative, easiest is to reset transform by recreating canvas size and re-setting ctx scale.
    // We'll reset transform by clearing context and reset strokeCache drawing.
    // Reset the canvas element width/height and scale again
    const ratio = window.devicePixelRatio || 1;
    // Remove any existing transform by reinitializing ctx transform via setTransform
    // but better to just rebuild canvas size and call redrawAll
    // Clear any previous transform by resetting width/height
    const w = canvas.clientWidth;
    const h = canvas.clientHeight;
    canvas.width = w * ratio;
    canvas.height = h * ratio;
    ctx.setTransform(ratio, 0, 0, ratio, 0, 0);
    redrawAll();
  }, 150);
});

// initial resize setup after assets loaded
setTimeout(()=> {
  // ensure canvas has right CSS size to fill the container
  canvas.style.width = '100%';
  canvas.style.height = '100%';
  // call once
  const ratio = window.devicePixelRatio || 1;
  const w = canvas.clientWidth;
  const h = canvas.clientHeight;
  canvas.width = w * ratio;
  canvas.height = h * ratio;
  ctx.setTransform(ratio,0,0,ratio,0,0);
  redrawAll();
}, 30);

</script>
</body>
</html>
